
# Java 컴파일 과정

## 개요
Java는 다른 언어들과 달리 독특한 컴파일 방식을 가지고 있다. "한 번 작성하면 어디서든 실행된다(Write Once, Run Anywhere)"는 Java의 철학을 구현하기 위한 방식이다.

## 전체 흐름
```
소스코드(.java) → javac 컴파일러 → 바이트코드(.class) → JVM → 기계어
```

## 단계별 과정

### 1. 소스코드 작성
```java
// HelloWorld.java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

### 2. 컴파일 (javac)
```bash
javac HelloWorld.java
```

javac 컴파일러가 하는 일:
- 문법 오류 검사
- 의미상 오류 검사  
- 바이트코드 생성
- 코드 최적화

### 3. 바이트코드 생성
컴파일이 완료되면 `HelloWorld.class` 파일이 생성된다. 이 파일은:
- 플랫폼에 독립적인 중간 코드
- JVM이 이해할 수 있는 형태
- 사람이 직접 읽기는 어려움

### 4. 실행 (JVM)
```bash
java HelloWorld
```

JVM이 바이트코드를 읽어서 해당 플랫폼의 기계어로 변환하여 실행한다.

## 왜 이런 방식을 사용할까?

### 플랫폼 독립성
일반적인 컴파일러(C, C++ 등)는 소스코드를 특정 플랫폼의 기계어로 직접 변환한다. 따라서 Windows용으로 컴파일한 프로그램을 Linux에서 실행할 수 없다.

하지만 Java는 바이트코드라는 중간 단계를 거치기 때문에, 한 번 컴파일한 `.class` 파일을 JVM이 설치된 어떤 플랫폼에서든 실행할 수 있다.

## JVM의 바이트코드 처리

### 클래스 로딩
JVM은 필요한 `.class` 파일들을 메모리로 로드한다.

### 바이트코드 검증
로드된 바이트코드가 안전한지 검사한다. 이 과정에서 악성 코드나 JVM 규칙을 위반하는 코드를 걸러낸다.

### 실행
바이트코드를 기계어로 변환하여 실행한다. 이때 두 가지 방식을 사용한다:

**인터프리터 방식**: 바이트코드를 한 줄씩 읽어서 즉시 기계어로 변환하여 실행

**JIT 컴파일 방식**: 자주 사용되는 코드는 미리 기계어로 컴파일해두고 재사용

## 실제 사용 예시

### 컴파일과 실행
```bash
# 컴파일
javac Calculator.java

# 실행
java Calculator
```

### 컴파일 옵션들
```bash
# 특정 폴더에 클래스 파일 생성
javac -d build/ Calculator.java

# 외부 라이브러리 포함하여 컴파일
javac -cp libs/library.jar Calculator.java

# 모든 경고 메시지 출력
javac -Xlint Calculator.java
```

### 바이트코드 확인해보기
```bash
javap -c Calculator
```
이 명령어로 생성된 바이트코드를 사람이 읽을 수 있는 형태로 볼 수 있다.

## 다른 언어와의 비교

| 언어 | 컴파일 방식 | 장점 | 단점 |
|------|------------|------|------|
| C/C++ | 소스코드 → 기계어 | 실행 속도 빠름 | 플랫폼 의존적 |
| Python | 인터프리터 방식 | 개발 편의성 | 실행 속도 느림 |
| Java | 소스코드 → 바이트코드 → 기계어 | 플랫폼 독립성 + 적당한 속도 | 초기 실행 시 약간의 오버헤드 |

## 핵심 정리

Java의 컴파일 과정은 **2단계 변환**이 핵심이다:
1. **javac**: 사람이 이해하는 코드를 JVM이 이해하는 코드로 변환
2. **JVM**: JVM 코드를 컴퓨터가 이해하는 코드로 변환

이 방식 덕분에 "한 번 작성하면 어디서든 실행"이라는 Java의 핵심 철학이 실현된다.
